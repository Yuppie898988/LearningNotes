# RISC-V版

[toc]

## 计算机抽象及相关技术

### 知识点

- 计算机组成：
  - 输入
  - 输出
  - 存储器
  - 数据通路
  - 控制器

**数据通路和控制器合称处理器**

- 响应时间/挂钟时间/运行时间：完成某项任务所需的总时间
    **降低响应时间总可以增大吞吐率**

- 吞吐率/带宽：单位时间内完成总工作量

- 机器字长：计算机进行一次整数运算所能处理的二进制数据位数

- 数据通路带宽：外部数据总线一次并行传送信息的位数

- 主存容量：$MAD \times MDR$。MAR为16位，MDR为32位，则为$64K\times 32$位

- $存储字长=MDR位数$

- $PC长度=MAR位数$

- $机器字长=计算机位数=ALU长度=通用寄存器长度$

### 八个伟大思想

1. 面向摩尔定律的设计：芯片上所集成的晶体管资源每18至24个月翻一番
2. 使用抽象简化设计：隐藏低层细节以提供给高层一个更简单的模型
3. 加速经常性事件
4. 通过并行提高性能
5. 通过流水线提高性能
6. 通过预测提高性能
7. 存储层次
8. 通过冗余提高可靠性：引入冗余组件在系统发生故障时可以替代失效组件并帮助检测故障

### 性能运算

$$
\begin{aligned}
CPU时间&=CPU时钟周期数 \times 时钟周期长度\\
&=\frac{CPU时钟周期数}{时钟频率}\\
&=指令数 \times CPI \times 时钟周期长度\\
MIPS&=\frac{指令数}{CPU时间\times 10^6}\\
&=\frac{时钟频率}{CPI\times 10^6}
\end{aligned}
$$

## 指令

### 知识点

- 1字节 = 8位；1字 = 4字节；双字 = 8字节 = 64位

- 32个64位寄存器

- RISC-V使用以字节为单位寻址
eg.对于双字数组A，编译`f = g + A[8]`，其中f,g,A的基址分别存放在x20,x21,x22中

```RISC-V
ld x9, 64(x22)
add x20, x21, x9
```

- RISC-V的指令都是**32位**长

- 跳转-链接指令：
    `jal  x1, ProcedureAddress`跳转至ProcedureAddress并$PC+4$写入x1
    `jalr x0, 0(x1)`跳转至返回地址
    `jal  x0, Label`无条件跳转
    `beq x0, x0, Label`无条件跳转

- **过程帧（活动记录）**：栈中包含过程所保存的寄存器和局部变量的段

- 帧指针指向帧的第一个双字（通常是保存的参数寄存器）

- 读取指令有有符号类型、无符号类型：例如lbu读取1字节并经过符号扩展至8字节

- **存储指令只有有符号类型**，因为其存储寄存器的低位端，不需要考虑符号

- 大立即数（79页）：
    1. lui指令将31位到12位加载到寄存器
    2. 将31位扩展至高32位
    3. addi加载低11位

- 如果加载的大立即数第11位为1，则会出现addi加负数的情况，需要lui时+1。以加载00101111 11111111为例（高位省略）：

    ```RISC-V
    lui  x19, 11
    addi x19, 111111111111
    ```

    如果lui此时加10，则addi相当于-1，最终加载的是011111 11111111。加1后则为110000 00000000 - 1 = 101111 11111111，加载正常。

- 长距离跳转:
    1. lui将地址的第12位至31位写入临时寄存器
    1. jalr将地址的低12位加到临时寄存器并跳转

- 远距离无条件跳转，将SB型指令改为UJ型。例如`beq x10, x0, L1`:

    ```RISC-V
        bne x10, x0, L2
        jal x0, L1
    L2:
    ```

- 寻址模式:
  - 立即数寻址
  - 寄存器寻址
  - 基址或偏移寻址
  - PC相对寻址

- 保留加载`lr.d rd, (rs1)`，将rs1加载至rd

- 条件存储`sc.d rd, rs2, (rs1)`，将rs2存储进rs1，若lr.d执行后rs1值不变则存储成功，rd为0；如果rs1值变化则存储失败，rd为1

- C程序变为可执行程序过程：
    1. 编译：将高级语言变为汇编语言程序
    2. 汇编：将汇编程序变为目标文件：机器语言模块
    3. 链接：将多个独立汇编的机器语言程序缝合生成可执行文件（静态）
    4. 加载器：将可执行文件加载到内存中

- 动态链接库：
  - 避免由于静态链接所有库文件导致镜像膨胀
  - 可以自动获取新版本的库程序
  - 只有链接/加载库过程时才会被调用

- 三条设计原则：
  - **简单源于规整**
  - **更少则更快**
  - **优秀的设计需要适当的折中**

### 指令表示

#### R型（用于寄存器）

|funct7|rs2|rs1|funct3|rd|opcode|
|-|-|-|-|-|-|
|7位|5位|5位|3位|5位|7位|

#### I型（用于带常数的算术指令）

|immediate|rs1|funct3|rd|opcode|
|-|-|-|-|-|
|12位(补码值)|5位|3位|5位|7位|

#### S型

|immediate[11:5]|rs2|rs1|funct3|immediate[4:0]|opcode|
|-|-|-|-|-|-|
|7位|5位|5位|3位|5位|7位|

eg.读取数值
`sd x9, 240(x10)`
$240_2 = 0000\ 1111\ 0000_2$，左边7位为111(十进制为8)，右边5位为10000（十进制为16）。相当于240右移5位，即：
$$
\frac{240}{2^5}=7 \cdots\cdots 16
$$
注：寄存器x9和x10存放于rs2和rs1

**ld和sd指令中基址寄存器均为rs1**

#### SB型（分支指令）

|imm[12]|imm[10:5]|rs2|rs1|funct3|imm[4:1]|imm[11]|opcode|
|-|-|-|-|-|-|-|-|
|1位|6位|5位|5位|3位|4位|1位|7位|

**12位立即数，忽略0位，只能跳转至偶数地址，可跳转至当前指令$\pm2^{10}$个字的地方**

#### UJ型（jal）

|imm[20]|imm[10:1]|imm[11]|imm[19:12]|rd|opcode|
|-|-|-|-|-|-|
|1位|10位|1位|8位|5位|7位|

**20位立即数，忽略0位，只能跳转至偶数地址，可跳转至当前指令$\pm2^{18}$个字的地方**

### 指令汇总

84页

## 算数运算

### 知识点

- 上溢：正指数太大而无法用指数字段表示的情况

- 下溢：负指数太大而无法用指数字段表示的情况

- 单精度浮点：32位字段，1位符号，8位指数，23位尾数

- 双精度浮点：64位字段，1位符号，11位指数，52位尾数

- 可以直接对浮点表示下的数比较，比较结果即为浮点数大小比较结果

- 由于指数段存在有符号数，例如$2^{-1},2^1$相比较，高位分别为$0 1111_1111,0 0000_0001$，这违背了不便于直接比较（指数为-1的数在浮点表示法中更大），所以引入**偏移量**

- **单精度偏移量为127**，**双精度偏移量为1023**

- 单精度指数部分为00000001到11111110，即$2^{-126}到2^{127}$

- 浮点寄存器f0没有硬连接到常数0，单精度值存在低32位

- 
    | 单精度 |      | 双精度 |      | 表示对象       |
    | ------ | ---- | ------ | ---- | -------------- |
    | 指数   | 尾数 | 指数   | 尾数 |                |
    | 0      | 0    | 0      | 0    | 0              |
    | 0      | 非0  | 0      | 非0  | 正负非规格化数 |
    | 1~254  | 任意 | 1~2045 | 任意 | 正负浮点数     |
    | 255    | 0    | 2047   | 0    | 正负无穷       |
    | 255    | 非0  | 2047   | 非0  | NaN            |

- 增加保护位、舍入位、粘滞位用于精准计算

### 溢出检测

1. 有符号溢出：
    正数相加$\lt 0$；负数相加$\ge 0$;正数减负数$\lt 0$；负数减正数$\ge 0$

2. 无符号溢出：
    和小于任何加数——加法溢出
    差大于被减数——减法溢出

3. mulhu的结果为0，64位乘法不溢出

4. mulh结果的所有位都是mul结果的符号位的复制，则64位有符号乘法没有溢出